# 为什么学习 Rust

我们已经进入 JavaScript 的第三阶段，越来越多的 JavaScript 工具将使用编译型语言进行编写。

得益于 Rust WebAssembly 工作组的不懈努力，Rust 编译为 WebAssembly 已成为可能。

## 编译型与解释型语言

### 编译型语言
编译型语言需要使用编译器，不同平台需要生成不同的机器语言。例如，Rust、C、C++ 等。

### 解释型语言
解释型语言通过解释器（如 V8）来生成机器语言，因此没有跨平台的问题。例如，JavaScript。

---

## Cargo：Rust 的构建系统和包管理器

- **创建项目**：  
  使用 `cargo new` 创建一个新项目。

- **构建项目**：  
  使用 `cargo build` 来构建一个项目。

- **构建并运行项目**：  
  使用 `cargo run` 一步构建并运行一个项目。

- **检查代码错误**：  
  使用 `cargo check` 构建项目而无需生成二进制文件，以便检查代码中的错误。

- **构建结果的存储**：  
  Cargo 不会将构建结果保存在与代码相同的目录中，而是将其存储在 `target/debug` 目录中。

- **发布优化**：  
  当项目准备好发布时，可以使用 `cargo build --release` 来进行优化构建。

---

## Rust 函数返回值

在 Rust 中，如果一个函数体以没有尾随分号的表达式结尾，那么该表达式会成为函数的返回值。实际上，花括号包起来的任意代码块都可以用作表达式。

---

## 单元测试

Rust 提供了强大的单元测试功能。在代码中，我们可以使用 `#[test]` 属性来标记测试函数。以下是一个示例：

```rust
#[test]
fn test_gcd() {
    assert_eq!(gcd(14, 15), 1);
    assert_eq!(gcd(2 * 3 * 5 * 11 * 17,
                   3 * 7 * 11 * 13 * 19),
               3 * 11);
}


```
* #[test]：标记 test_gcd 为测试函数，在正常编译时会跳过它。
* 但是，当我们使用 cargo test 命令运行程序时，Cargo 会自动包含并运行所有标记为测试的函数。
* 测试函数可以分散在源代码树中的任何位置，紧跟着它们所测试的代码。cargo test 会自动收集并运行这些测试函数。