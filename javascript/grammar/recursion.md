---
outline: deep
layout: doc
---
## 递归的结构
让我们写一个函数 pow(x, n)，它可以计算 x 的 n 次方。换句话说就是，x 乘以自身 n 次

```js
         if n==1  = x
             /
pow(x, n) =
             \
              else     = x * pow(x, n - 1)
```

* 当n=1我们很容易获得结果，这叫做 **基础** 的递归
* 否则，我们可以用 x * pow(x, n - 1) 表示 pow(x, n)，这叫一个**递归步骤**。接下来的步骤将其进一步简化，直到 n 达到 1
## 执行上下文和堆栈
有关正在运行的函数的执行过程的相关信息被存储在其 **执行上下文** 中。

执行上下文 是一个内部数据结构，它包含有关函数执行时的详细细节：当前控制流所在的位置，当前的变量，this 的值（此处我们不使用它），以及其它的一些内部细节。

一个函数调用仅具有一个与其相关联的执行上下文。

当一个函数进行嵌套调用时，将发生以下的事儿：

1. 当前函数被暂停；
2. 与它关联的执行上下文被一个叫做 执行上下文堆栈 的特殊数据结构保存；
3. 执行嵌套调用；
4. 嵌套调用结束后，从堆栈中恢复之前的执行上下文，并从`停止的位置恢复外部函数`。
:::tip :rocket:
当我们完成子调用后 —— 很容易恢复上一个上下文，因为它既保留了变量，也保留了当时所在代码的确切位置。

任何递归都可以用循环来重写。通常循环变体更有效。
:::
